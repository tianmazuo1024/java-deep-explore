# 第三篇 工程实践篇

现在的互联网大厂和过去的软件小作坊之间，最大的区别并非人数变得更多了，业务变得更复杂了，而是其日益流程化、规范化和系统化的软件开发方式，这种流程化、规范化和系统化的方式，通常也被称之为“软件工程（化）”。就像盖房子时的脚手架一样，虽然钢筋混凝土很坚固，但它从浇筑到凝固也是需要一个过程的，如果没有这些脚手架的干预，那么“质变”过程绝不会凭空出现。对于软件项目来说也是一样，软件工程就相当于开发过程中的脚手架，它不仅能够帮助工程师们快速启动项目，减少枯燥的重复性工作，提升开发效率，而且它提供了一套标准化的开发过程。所谓“功夫在诗外”——掌握这些软件开发能力之外的能力，不仅能够统一软件开发团队的想法和做法，也能提高软件产品的质量，让软件变得更容易使用和维护，进而提高软件研发团队整体的开发水准。

本篇包括如何以图表强化软件协同，如何开发和调试出性能卓越的接口，如何以流水线的方式部署应用服务，如何合理地运用开发过程提升软件质量，以及如何做好开源软件。本篇内容是一次对软件工程实践的系统性回顾，全部以实践为主，取其精华，扔其鸡肋，详细阐述了笔者多年来的软件工程实践经验和心得体会。

希望本篇内容能够将广大读者从“西绪福斯的苦役”中解脱出来。

## 第14章 字不如表不如图

俗话说“字不如表，表不如图”。不管是什么行业什么岗位，做什么工作，工程师也好，设计师也罢，哪怕是办公室的Office Lady或外卖小哥，在日常和人沟通之时，总会有比划几下，或者画个图让对方明白自己意思的时候。因为相比于说一大堆话，用一张图显然可以让对方更快地明白自己所要表达的意思。软件开发中也是如此，不同的工程师，不同的团队，不同的部门之间在合作时，总会有大量的正式或非正式的文档、会议、IM消息，如果将之归类的话，那么它们无非分为：UML图、ER图、架构图以及项目相关图表，本章就来将它们一一盘点。

### 14.1 UML建模语言

UML是“Unified Modeling Language”的英文缩写，称为“统一建模语言”，其诞生历史可以追溯到20世纪80年代末和90年代初。当时软件开发领域面临着快速发展和复杂化的挑战，为了更好地描述、设计和理解软件系统，人们意识到需要一种标准的用于彼此协作和沟通的“语言”，以便更好地描述、设计和理解软件系统。为此，UML提供了一套图形化的符号和规则，用于描述软件系统的结构、行为、交互等方面，帮助工程师们更好地分析、设计和沟通软件系统。这套图形化的符号和规则，就如同工程建筑行业中起着至关重要作用的蓝图一样，是众多工程师们用于设计、施工和沟通的“语言”。

UML包括了多种不同类型的设计图，按照分类，它们包括：

1. 结构图：用于描述系统的静态结构，包括类图（Class Diagram）、对象图（Object Diagram）、组件图（Component Diagram）、部署图（Deployment Diagram）；
2. 行为图：用于描述系统的动态行为，包括用例图（Use Case Diagram）、活动图（Activity Diagram，也叫流程图）、状态图（State Diagram）、时序图（Sequence Diagram）、通信图（Communication Diagram）；
3. 交互图：描述系统中对象之间的交互关系，包括时序图（Sequence Diagram）和协作图（Collaboration Diagram）。

但出现频率最高的几种分别是用例图、类或对象图、流程图、状态图和时序图。如果按软件项目的开发阶段来分，它们的作用如图14-1所示。

> 图14-1 不同阶段可用的UML设计图

![图14-1 不同阶段可用的UML设计图](chapter14/14-01.png)

可以画图的工具很多，但能完整遵循标准UML语法的工具很少，笔者经常使用的只有两种：一是IBM的Rational Rose，可惜直到2010年发布Rose 7.0.0.4 iFix001版本之后就再也没有更新过，目前已经不可用了。二是StarUML，它很好地继承了Rational Rose大部分功能，且至今仍在更新，而且风格上也是一脉相承，如图14-2所示。

> 图14-2 StarUML界面

![图14-2 StarUML界面](chapter14/14-02.png)

本章的内容均以StatUML 3.2.2版本作为UML工具来展开讲解。当然，也许有些读者更习惯使用其他的软件，例如VISIO、ProcessOn等。

工具并不重要，重要的是设计思想和沟通方式。

#### 14.1.1 用例图

所谓“用例（Use Case）”，可以把它简单地理解为一个独立且完整的用户功能需求，它用来描述用户与系统应用之间的交互，同时也展现了用户、系统、需求这三者之间，以及它们自身之间的关联关系。通过用例，工程师可以知道：

1. 系统为谁服务？谁是最终用户（而非中间用户）？
2. 最终用户希望系统提供什么样的服务？又希望得到什么样的输出？
3. 最终用户能为系统提供什么样的输入？有哪些约束条件？

额外说明一点：在用例中务必明确谁才是最终用户。例如开发一个项目管理系统PMS时，可能会由一些业务方的主管、经理们提出具体的需求。他们虽然也睡这个系统的用户，但不一定是最终用户，因为最终用户一定是那些每天都要接触并使用PMS的人：他们需要每天在PMS中提交工作日志，记录项目问题，汇报项目进度等，他们对于系统的需求和体验直接决定PMS开发的成败。

用例图主要有四个组成部分：

1. 参与者（Actor）：参与者并非具体的人，而是指存在于外部并直接与系统交互的人、其他系统、子系统或对象。它在UML中用一个“小人”表示，如图14-3所示。

> 图14-3 参与者Actor

![图14-3 参与者Actor](chapter14/14-03.png)

2. 用例（Use Case）：用来描述需要给参与者提供的功能或服务。它必须由参与者来执行，获取参与者的输入，并将输出结果反馈给参与者或系统，如图14-4所示。

> 图14-4 用例Use Case

![图14-4 用例Use Case](chapter14/14-04.png)

3. 关系（Association）：表示参与者和用例之间的联系，它也可以用来表示参与者和参与者、用例和用例之间的关系。常见的关系如表14-1所示。

> 表14-1 用例图中常见的关系

| 关系类型 | 描述 |
|:---:|:---:|
| 关联 | 参与者之间或用例之间的关系 |
| 包含 | 用例之间的关系 |
| 扩展 | 用例之间的关系 |
| 泛化 | 参与者之间或用例之间的关系 |

  - “包含”关系类似于将公共方法抽象出来单独放在一个方法里，由其他方法引用。例如“添加用户”和“修改用户”最终都会涉及到“保存用户”的操作，那么它们都“包含”“保存用户”，如图14-5所示。

> 图14-5 用例之间的“包含”关系

![图14-5 用例之间的“包含”关系](chapter14/14-05.png)

  - “扩展”关系是把新的功能加入到已有用例中。例如在用例“验证码登录”中，默认使用的是短信验证码，但是也可以通过语音验证码完成登录，那么用例“语音验证码”就是用例“验证码登录”的扩展用例，如图14-6或图14-7所示。

> 图14-6 用例之间的“扩展”关系

![图14-6 用例之间的“扩展”关系](chapter14/14-06.png)

> 图14-7 用例之间的“扩展”关系（箭头方向相反）

![图14-7 用例之间的“扩展”关系（箭头方向相反）](chapter14/14-07.png)

  有的用例图中扩展关系的箭头方向为图14-6那样，而有的又是图14-7那样，哪一种都可以，只要内部统一就好，“包含”关系也一样。

  - “泛化”等同于对象间的继承关系。例如参与者中可分为“普通用户”和“管理员用户”，那么“管理员用户”就可以从“普通用户”继承而来；而“账户登录”和“扫码登录”也可以从“登录”用例继承，如图14-8所示。

> 图14-8 “泛化”关系

![图14-8 “泛化”关系](chapter14/14-08.png)

4. 系统（System）：是用例需要描述的对象，它可以是一个软件平台或者一个硬件设备，或者是一次促销活动，也可以是一个更大的系统的一部分。它有自己的边界，由参与者、用例和关系共同组成。

想画出完整的用例图，掌握以上内容就已经足够了。

另外，在用例文档中切忌啰嗦，一般都是非常简洁的“名词 + 动词”形式来描述业务主流程，至于分支流程和边界条件等详细描述，可以在需求说明书中给出。例如，一个良好的用例文档就像这样：

1. 用户打开登录界面；
2. 用户输入用户名和密码；
3. 系统确认用户名和密码；
4. 用户登录成功；
5. ......

而比较啰嗦的反面典型则可能会是这样：

1. 用户打开浏览器，然后在地址栏中输入浏览器地址......，浏览器确认Cookie......；
2. 页面显示出登录界面，用户单击页面输入框，然后输入用户名和密码；
3. 输入用户名密码时弹出人机确认对话框，用户确认身份，系统读取用户输入的登录名称和密码；
4. 后台先验证用户名是否存在，核对用户密码是否正确。如果用户存在且密码匹配则用户登录成，否则登录失败，给出页面提示；
5. ......

在画用例图时，只考虑需要实现什么功能即可，至于如何实现，暂时不必关心。下图是笔者依据较为典型的登录场景绘制的用例图，如图14-9所示。

> 图14-9 登录用例

![图14-9 登录用例](chapter14/14-09.png)

#### 14.1.2 类图

用例图用来描述需求的结构及其关系，而类图则反应系统中类或对象之间的结构与关联关系。这是一种静态的建模方法，是对现实世界的抽象。例如在之前讲述Java关键知识点和多线程等内容时，就出现过JDK中类继承结构图。类图分为两大部分：一是类的基本属性，包括类名、类的属性和类的方法，如图14-10所示。

> 图14-10 用户类的类图

![图14-10 用户类的类图](chapter14/14-10.png)

在图14-10的类图中，用户类User中的各种符号分别说明如下：

1. +：表示public，公共成员变量或方法；
2. -：表示private，私有成员变量或方法；
3. #：表示protected，受保护成员变量或方法；
4. ~：表示package，只对同一包中的其他类可见；
5. 下划线：表示这是一个static静态成员变量或方法；
6. 斜体：表示抽象方法。也可以用两个尖括号表示抽象类，比如：<<抽象类>>。

类图的另外一部分就是类与类之间的关系。在UML类图中，类之间共有六种关系：

1. 首先是关联关系，这是一种“拥有”的关系，它使一个类可以引用另一个类的属性和方法，如图14-11所示。

> 图14-11 类的关联关系

![图14-11 类的关联关系](chapter14/14-11.png)

这种关联关系用代码来表示就如代码清单14-1所示。

> 代码清单14-1 类的关联关系

```java
public class User {
    private Address address;
}
public class Address {
    private String city;
    private String street;
}
```

代码清单14-1展示的是一种单向依赖关系，如果类A关联类B，且类B也关联了类A，那么它们就是一种双向关联关系。但这种关系是不推荐的，因为可能会引发循环依赖的问题。

2. 其次是聚合关系，这是一种特殊的关联关系，是一种比较强的关联。它描述的是整体和部分的关系，而整体和部分是可以分开的。例如计算机的组成部分包括CPU和显示器，但离开了计算机CPU和显示器依然能够独立存在，如图14-12所示。

> 图14-12 类的聚合关系

![图14-12 类的聚合关系](chapter14/14-12.png)

这种聚合关系用代码来表示就如代码清单14-2所示。

> 代码清单14-2 类的聚合关系

```java
public class Computer {
    private CPU cpu;
    private Monitor monitor;
    public Computer(CPU cpu, Monitor monitor) {
        this.cpu = cpu;
        this.monitor = monitor;
    }
}
public class CPU {
}
public class Monitor {
}
```

3. 第三是组合关系，它和聚合关系类似，但比聚合关系更进一步，因为它规定了整体和部分不能分开。例如用户可以有积分和等级，但积分和等级离开了用户就没有单独存在的意义了，如图14-13所示。

> 图14-13 类的组合关系

![图14-13 类的组合关系](chapter14/14-13.png)

这种组合关系用代码来表示就如代码清单14-3所示。

> 代码清单14-3 类的组合关系

```java
public class User {
    private Point point;
    private Level level;
    public User() {
        this.point = new Point();
        this.level = new Level();
    }
}
public class Point {
}
public class Level {
}
```

4. 再就是实现关系，其实它就是类实现某个接口，如图14-14所示。

> 图14-14 类的实现关系

![图14-14 类的实现关系](chapter14/14-14.png)

因为这种实现关系极为常见，因此就不再单独列举代码示例了。

5. 既然有了接口的实现，那么肯定也会有类的继承关系，这就是UML类图中的第五种关系：泛化关系，如图14-15所示。

> 图14-15 类的泛化关系

![图14-15 类的泛化关系](chapter14/14-15.png)

6. 最后是一种是依赖关系，这种关系和关联有些类似，但比关联关系更宽泛，如图14-16所示。

> 图14-16 类的依赖关系

![图14-16 类的依赖关系](chapter14/14-16.png)

只要类B满足下面条件中的任意一个，就说类A依赖类B：

1. 类A中有成员变量的类型是类B；
2. 类B是类A方法的返回类型；
3. 类B是类A方法的参数类型；
4. 类A的方法中用到了类B。

#### 14.1.3 流程图

用例图和类图相对来说复杂一些，而其他的UML图和它们相比就简单多了。例如流程图就是将业务流程的各个环节和触发条件按照事件发生发展的顺序展现出来。以用户账号密码登录流程为例，其流程图如图14-17所示。

> 图14-17 带泳道的账号密码登录流程

![图14-17 带泳道的账号密码登录流程](chapter14/14-17.png)

在上图中，用黑色实心圆“●”来表示流程初始，而用“☉”来表示流程结束。有三个竖长的矩形，分别是“用户”、“后端”和“前端”，这在流程图中称为“泳道”，就像泳池中的泳道一样，所以流程图有时候也叫“泳道图”。这些泳道代表一个个驱动业务开展的对象，它们都是事件或者条件的触发者。但有的流程图并没有这些泳道，效果也是一样的，如图14-18所示。

> 图14-18 无泳道的账号密码登录流程

![图14-18 无泳道的账号密码登录流程](chapter14/14-18.png)

比较上面两幅图，除了一个有泳道，一个没有泳道外，它们之间没有任何本质区别。流程图是各类需求说明文档和系统设计文档中的主要组成部分之一，只要业务逻辑完整，各种分支条件清晰，相信任何人都可以轻松地画出它。

#### 14.1.4 状态图

状态图和流程图有些类似，但它关注的不是业务流程的推进，而是某些业务领域在事件发生时的状态变化，例如订单状态。有些UML图中将状态图弄的很复杂，包括诸如组合状态、历史状态、状态机等概念。一般稍微复杂一点的状态图会类似图14-19所示那样。

> 图14-19 状态图的“模板”

![图14-19 状态图的“模板”](chapter14/14-19.png)

和流程图类似，在状态图中也用黑色实心圆“●”来表示初态，意思是还没有产生任何状态的时候。用“☉”来表示终态，也就是所有状态均已全部出现且再无新的状态出现之时。当状态A经过事件1时，如果符合条件A，就转换到状态B，否则就转换到状态C。状态C可以通过条件B完成自身状态的不断循环检查，例如已创建的订单如果未付款，那么它是否还在付款超时时间之内等这样的循环检查条件。只有当状态B和状态C同时满足业务约束A时，业务才能继续转换到状态D并进而完成。

其实大多数的状态图都没有这么复杂，而且也基本不需要复合状态、历史状态，甚至状态机，因为如果搞得太复杂有可能不但达不到沟通的目的，反而会适得其反。以终端用户视角的订单履约状态流转为例，其状态图如图14-20所示。

> 图14-20 终端用户视角的订单履约状态图

![图14-20 终端用户视角的订单履约状态图](chapter14/14-20.png)

#### 14.1.5 时序图

时序图又被称为序列图（Sequence Diagram），它通过对象之间互相调用方法以及发送消息的时间顺序，来显示多个对象之间的动态协作过程。例如在之前讲述权限相关知识的时候，就用一个时序图来展现出了第三方授权登录的OAuth 2.0流程。

时序图是一种将类图和流程图结合到一起的一种UML交互图，它既有对象的方法调用，也有调用时的流程展现。相对于其他UML图，时序图更强调交互的时间顺序，同时也能很直观地描述并发过程。时序图的组成部分也比较多，但和状态图一样，在画图时真正需要用到的并不多。一个最简单的时序图一定会包括这四类组件：对象、生命线、关联消息和控制焦点，如图14-21所示。

> 图14-21 时序图的组成部分

![图14-21 时序图的组成部分](chapter14/14-21.png)

自关联消息和应答消息则不一定会有。对象可以有三种命名方式：

1. 第一种是将对象名和类名都显示出来，例如，“Chrome浏览器 : 客户端”，它的形式是“对象 : 类”；
2. 第二种方式是只显示类名，例如“客户端”；
3. 第三种方式是只显示对象名，例如“Chrome浏览器”。

这三种方式哪一种都可以，喜欢哪种就用哪种。

生命线在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。当对象A调用对象B的方法时，就从对象A拉出一根实线箭头到对象B，这就是关联消息，可以写上过程描述，也可以直接写上调用方法，例如上图中的第2步中的内容就可以换成是“2: login()”。如果对象A是调用自身的方法，那么就有一个指向自身的箭头，表示自关联消息。而所谓应答消息则类似于方法调用后的返回值。控制焦点又称为激活期，用来表示当前时间段内对象将要执行的操作，用一个竖长方条表示。搞清楚了时序图的结构后，就不难用它来画出与业务相关的对象方法调用过程了。例如，如果用时序图来画出用户在电商网站的购物过程，那么将会类似于图14-22所示内容。

> 图14-22 电商网站购物时序图

![图14-22 电商网站购物时序图](chapter14/14-22.png)

### 14.2 ER图

ER图是英文“Entity-Relationship Diagram”的翻译，称为“实体-关系图”，它是一种用于描述数据模型的图形化工具。ER图主要用于表示数据实体Entity（通常对应于数据表）、属性Attribute（通常对应于数据表中的字段）和实体之间的关系Relationship（即数据表之间的关联），它是数据库设计中最为常用的工具，没有之一。通过ER图，可以清晰地展示出数据模型中各个实体之间的关系，有助于数据库设计人员理解需求和设计出合理的数据（库）模型。

#### 14.2.1 逻辑模型

ER图从概念上分为逻辑模型与物理模型，这两类模型其实本质上是同一个，只是详细程度不同。逻辑模型描述了数据之间的逻辑关系，它独立于具体的数据库管理系统DBMS或存储结构。逻辑模型通常更侧重于抽象的逻辑概念，而不涉及具体的物理存储细节。ER图由三要素组成：

1. 实体Entity：可以是现实世界的业务对象，例如书籍、作者、读者等；也可以是一些系统中的逻辑对象。比如消息、子系统、接口等。在ER图中，实体使用矩形框来表示；
2. 属性Attribute：用来描述组成实体的要素，也就是某个实体所拥有的属性，可以把它理解为数据表字段或类的成员变量；
3. 关系Relationship：即实体与实体之间的联系，而且还能通过数字表示实体之间的数量对照关系。例如，一个出版社可以出版多本书籍，而一本书籍可以有多名读者，这就是简单的一对多关系。

大多数架构师们应该会比较熟悉PowerDesigner，它是一款由Sybase公司开发的建模工具，能够同时支持UML建模语言和ER图。只不过它有个缺点，就是只能在Windows环境下运行，如果想在其他操作系统，例如MacOS或Linux中使用会较为麻烦，需要安装一些辅助工具才行。其实常用的数据库客户端管理工具Navicat就完全可以胜任用ER图建模的工作，如图14-23所示。

> 图14-23 Navicat的建模功能

![图14-23 Navicat的建模功能](chapter14/14-23.png)

Navicat可以支持概念数据模型、逻辑数据模型和物理数据模型。所谓概念数据模型比逻辑数据模型更抽象，它只有实体及实体间的关系，而去除了属性，如图14-24所示。

> 图14-24 Navicat的概念数据模型

![图14-24 Navicat的概念数据模型](chapter14/14-24.png)

上图展示了两个简单的实体，即作者和书籍之间的对应关系：一个作者可以出版至少一本，也可以出版多本书籍。而一本书籍至少要有一个作者，也可以有多个作者。可以看到，Navicat中的概念模型是如此的简单，所以这种模型一般可以用逻辑模型来替代它，如图14-25所示。

> 图14-25 Navicat逻辑数据模型

![图14-25 Navicat逻辑数据模型](chapter14/14-25.png)

由于涉及到属性字段，因此相比于概念模型，逻辑模型多了所谓的“中间表”实体，也就是“作者-图书关联”实体，它是一种多对多的关系。在Navicat中有六种实体间的映射关系，这六种关系分别是：

1. None：表示没有任何对应的实体。Navicat用一根直线来表示这种关系，如图14-26所示。

> 图14-26 “None”映射关系

![图14-26 “None”映射关系](chapter14/14-26.png)

2. One and Only One：表示有且仅有1个对应的实体，如果双方都是这种关系，那就是基本的一对一映射关系。例如，学生和学籍之间就是如此。Navicat用图14-27来表示这种关系。

> 图14-27 “One and Only One”映射关系

![图14-27 “One and Only One”映射关系](chapter14/14-27.png)

3. Many：有多个对应的实体。例如，1个班级有多个学生。Navicat用图14-28来表示这种关系。

> 图14-28 “Many”映射关系

![图14-28 “Many”映射关系](chapter14/14-28.png)

4. One or Many：有至少1个，也可以有多个对应的实体。例如，1本书籍至少要有1个作者。Navicat用图14-29来表示这种关系。

> 图14-29 “One or Many”映射关系

![图14-29 “One or Many”映射关系](chapter14/14-29.png)

5. Zero or One：有0个或1个对应的实体，也就是要么有1个，要么没有。例如，公民和身份证之间的关系。每个人在未成年之前都可以没有身份证，但成年之后最多只有1个身份证。Navicat用图14-30来表示这种关系。

> 图14-30 “Zero or One”映射关系

![图14-30 “Zero or One”映射关系](chapter14/14-30.png)

6. Zero or Many：有0个或多个对应的实体，例如用户和聊天群的关系就属于这种，某个用户可以没有加入任何聊天群，也可以在多个聊天群中。Navicat用图14-31来表示这种关系。

> 图14-31 “Zero or Many”映射关系

![图14-31 “Zero or Many”映射关系](chapter14/14-31.png)

至于实体间的关系到底应该是哪一种，这需要根据具体的业务规则而定。例如，对于现实世界的书籍来说，至少要有1个作者与之对应，也可以有多个作者共同完成一本书。

#### 14.2.2 物理模型

在搞清楚逻辑模型之后，物理模型就很容易明白了，除了要添加更详细的字段属性值之外，它和逻辑模型基本没什么区别，而且从模型设计图的外观上也可不出什么不同，如图14-32所示。

> 图14-32 Navicat物理数据模型

![图14-32 Navicat物理数据模型](chapter14/14-32.png)

上图的物理数据模型和图14-25的逻辑数据模型之间看不出任何差异，但它们确实是两种不同的模型。在PowerDesigner中，物理模型是可以直接转换为SQL脚本的，所以不同的软件工具使用时，也会有不同的功能与便利。

数据字典，是一种存储元数据信息的集合，通常以表格的形式呈现，用于描述数据库中各个数据元素（data element）的定义、结构和属性。数据字典记录了数据表的数据项、数据结构、数据类型、取值范围、关系以及数据之间的约束等信息。

在数据字典中，常见的信息包括：

1. 数据项（Data Item）：描述数据库中的数据元素，即字段；
2. 数据类型（Data Type）：指定数据项的类型，如整数、字符、日期等；
3. 数据长度（Data Length）：指定数据项可以存储的最大长度和精度；
4. 取值范围（Value Range）：指定数据项允许的取值范围，这个一般不需要；
5. 数据关系（Data Relationship）：描述数据项之间的关系，如主键-外键关系等；
6. 约束条件（Constraint）：描述对数据项的约束条件，如唯一性约束、非空约束等。

通过数据字典，用户可以更好地理解数据库中的数据结构和含义，从而更有效地进行数据库设计、开发和管理工作。

以图14-32的物理数据模型为例，其数据字典的示例如表14-2所示。

> 表14-2 数据字典示例

<table>
	<tr>
		<th colspan="2">数据表</td>
    <th colspan="3">default.author信息表</td>
    <th colspan="2">表引擎</td>
    <th colspan="3">MyISAM</td>
	</tr>
  <tr>
		<th colspan="2">唯一索引</td>
    <th colspan="3">无</td>
    <th colspan="2">字符集</td>
    <th colspan="3">utf8mb4 / utf8mb4_general_ci</td>
	</tr>
	<tr>
		<th>字段</td>
		<th>类型</td>
    <th>长度</td>
    <th>精度</td>
    <th>默认值</td>
    <th>非空</td>
    <th>外键</td>
    <th>主键</td>
    <th>字符集</td>
    <th>注释</td>
	</tr>
  <tr>
		<td>guid</td>
		<td>bigint</td>
    <td>20</td>
    <td>0</td>
    <td></td>
    <td></td>
    <td></td>
    <td>非自增</td>
    <td></td>
    <td>全局唯一ID</td>
	</tr>
  <tr>
		<td>name</td>
		<td>varchar</td>
    <td>64</td>
    <td>0</td>
    <td>''</td>
    <td>是</td>
    <td></td>
    <td></td>
    <td>utf8mb4</td>
    <td>作者名称</td>
	</tr>
</table>






### 14.3 架构图




#### 14.3.1 架构思维






#### 14.3.2 架构图模板






#### 14.3.3 架构图分类





### 14.4 其他




#### 14.4.1 甘特图






#### 14.4.2 鱼骨图






#### 14.4.3 思维导图





### 14.5 本章小节

常言道“一图胜千言”。如果对一个从未见过榴莲的人，通过言语来向他来描述榴莲的样子，恐怕1000个人就会有1000种不同的说法。但如果给他看一张榴莲的照片，他就会立刻明白榴莲的样子了，而不会被言语所“迷惑”。同样，在软件开发的设计、开发和部署等各个阶段，也有诸多可使用的相关图表，用好这些图表，不但能起到事半功倍的作用，而且也能消除歧义、统一思想、节省时间，有效地提高团队协作的效率和效果。

在软件系统的设计、开发、测试和交付阶段，常见且常用的图表包括UML图、ER图、架构图和诸如甘特图、鱼骨图、思维导图等各类图表，它们涵盖了一名软件工程师在其职业生涯中所能遇到的图表的90%左右。

UML作为建模语言，是一套专用于描述系统需求、行为、结构、交互和状态的符号规则。通过UML用例图，需求分析人员、项目经理或产品经理可以用一种更为精炼有效的方式，来告诉开发工程师系统需要完成什么样的功能，有哪些输入和输出，又需要遵循哪些前提条件，尤其是对于不同的角色来说，他们又是如何使用这同一套系统的。类图则为系统的结构和交互铺设了龙骨，描述了系统中的类、接口、关系和属性等元素，将现实世界的各种存在抽象为软件系统的虚拟实体。既反向验证了系统设计是否符合需求，以帮助开发人员及时发现和解决设计上的问题，又可以作为代码生成工具的输入，帮助开发人员自动生成部分代码，提高开发效率。UML中的流程图是在实际工作工作接触最多的图表之一，原因之一就是但凡业务则必有流程，而将流程描述清楚后用系统来实现，则一定会借助流程图工具。而且，通过分析流程图，还可以发现流程中的瓶颈和冗余，进而优化流程，提高效率和质量。现实世界的业务实体往往不止一种状态，而是在不同前提条件下和不同业务环节中，表现出多面性。找到并描述这些不同的业务侧面，就是UML状态图的职责。如果说状态图是从比较“宏观”的角度来看待业务逻辑的转换和交互的话，那么时序图则是从“微观”的层面来描述系统中对象与对象之间、方法与方法之间的交互行为、调用顺序和消息传递。通过时序图，既可以反映对象在交互过程中的状态变化，帮助工程师理解系统的动态行为，也可以理清对象之间的交互和消息传递逻辑。

在数据库设计阶段，最常用的设计图表就是ER图，没有之一。因为ER是着眼于映射为数据库表结构的现实中的实体，而着手于它们之间的关系。通过ER模型，工程师或系统分析员、DBA们可以用于对系统中的数据进行建模，包括实体、属性和关系等，帮助他们理清数据之间的关系、结构和各种约束。ER图中的逻辑模型关注的是实体间的关系，例如一对一、一对多和多对多等关系。而Navicat则提供了六种可选的关系，它们是None、One and Only One、Many、One or Many、Zero or One和Zero or Many。ER图中的物理模型只是比逻辑模型的属性更多而已，但不同的工具在创建不同的模型时会有不同的作用，例如，PowerDesigner就可以依据物理模型逆向创建出SQL脚本。因此有时物理模型会用数据字典来替代。

从工程师成长为架构师，并非是靠画几张漂亮的架构图，而是需要怎整理解并掌握架构思维，它们包括但不限于抽象思维、解构思维、集成思维、分层思维、发散思维、结构化思维、迭代思维、系统思维和模式匹配等。虽说掌握这些思维、模式需要耗费不少的时间浸润，但先从模板开始学着画架构图也是个不错的办法。笔者依据个人多年的工作经验整理了几种常见的架构模板。架构图可以分为业务架构图、应用架构图、技术架构图和数据架构图几类。但在实际工作中，并不会完全照着这些分类来画架构图，而是可能会将诸多类型混杂在一起。例如有些系统架构图，既有业务架构图，又有应用架构图和技术架构图的影子。

在项目管理中经常会用到甘特图，它不仅仅可以用于项目管理，对于制定个人工作计划，它也是完全可以胜任的。甘特图只是项目管理思想的一种体现，只要具备了成熟的项目管理思想，即使是不画甘特图，工程师或项目经理对于项目计划、进度的掌控也会自然而然地出现。鱼骨图是一种类似于鱼骨形状的因果图。通过它可以定义问题、找到产生问题的根本原因和找到如何解决问题的办法。但如何使用它可不仅仅限于寻找“因果循环”，因为工作总结、迭代计划同样可以用鱼骨图来做。常见的思维导图称为Mind Map，但是其实还存在另外一种思维导图，称之为Thinking Map，因为具有八种不同的类型的图示，因此又叫它八大思维图示法。其中的圆圈图、气泡图、双气泡图、多流程图和桥形图虽然使用场合不多，但对于想象、类比、归因等思维方式的训练，却是很好的实践方法。

### 14.6 本章练习

1. 请补全图14-18登录流程，将用户名格式、密码连续错误三次锁定账户、人机验证、是否单点登录等条件加入进去。当然，也可以加入其他可能的业务约束。

2. 请参照图14-18登录流程，画出用户注册流程、验证码登录流程、扫码登录流程和第三方账号登录流程。

3. 请尝试参照图14-20中的流程图，画出平台视角的订单履约状态流转过程，以及订单履约的时序图。

4. 请尝试参照某图书电商，给咚咚图书电商画出其平台业务架构图、应用架构图、技术架构图和数据架构图。

5. 如果让一个7人组成的敏捷开发团队（产品经理1、Java工程师3、前端工程师1、UI设计师1、测试工程师1）来开发这个咚咚图书网，如何通过甘特图排期？
