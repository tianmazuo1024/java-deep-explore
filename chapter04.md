## 第4章 JVM GC

作为一门诞生之初就把跨平台作为特色之一的编程语言，可以说没有JVM（Java Virtual Machine，Java虚拟机）也就没有Java今日之繁荣。而对于广大的Java工程师来说，它既是一种历练，也是一份礼物。

本章从具体例子出发，讲解了GC分代模型、GC算法与策略、G1 GC、GC日志和可视化工具等内容，并以一步一图的方式层层剖析，力求以大白话和直观的方式，让读者理解JVM GC背后所遵循的策略思想和设计哲学。

### 4.1 JVM GC概览

JVM处于Java的核心地位，JMM（Java Memeory Model，Java内存模型）和Java多线程也是基于JVM之上的技术。

就像家里的柴、米、油、盐、酱、醋、茶分别放在不同的罐子里那样，当程序代码中的对象实例、成员变量、成员方法、方法内的局部变量、静态变量、常量等进入JVM时，也会分门别类地去到它们该去的地方，如图4-1所示。

> 图4-1 JVM类加载的大致流程

![图4-1 JVM类加载的大致流程](chapter04/04-01.png)

整个JVM类加载及GC垃圾回收机制的大致流程是：

1. 首先，JVM进程启动，类加载器通过双亲委派机制将需要使用的类的字节码加载到JVM中；
2. 然后程序执行main()方法，并在main线程中将main()方法压入JVM栈；
3. 如果需要创建实例对象或数组等引用对象，则在JVM堆中创建，再由JVM栈的局部变量引用JVM堆中实例对象的地址；
4. 由方法区中保存各个方法的对象、变量等数据，依次入栈再出栈；
5. 当内存资源不再被使用时，JVM会通过一个专门的线程将其回收再利用。

### 4.2 GC分代模型

垃圾回收（Garbage Collection，GC）一直都是JVM中最核心和最复杂的一块区域，前面讲过堆和栈的不同的作用，正是这种对数据的“区别对待”，才是让垃圾回收机制得以顺利进行的保证。

#### 4.2.1 “幼儿园”与“敬老院”

可以说在代码里创建的大多数对象，其存活周期都是极其短暂的，会被频繁创建与销毁，而只有少数对象能长期存活。因此，对这两种处于不同生存周期的对象，Java也将它们分别保存在两块不同的地方：一个叫做“年轻代”（类似于幼儿园），一个叫做“老年代”（类似于敬老院）。如图4-2所示。

> 图4-2 Java分代模型

![图4-2 Java分代模型](chapter04/04-02.png)

在上图中，年轻代的Work实例对象用完后就立即被销毁，而老年代的Person静态变量family则没有。所以：

1. 年轻代存放的是创建和使用完之后马上就要回收的对象；
2. 老年代存放的是创建之后需要长期存在的对象。

不过在JDK 1.8之前，JVM中还存在着一种叫做“永久代”的内存区域，而JDK 1.8之后就被Metaspace（元空间）替换掉了。Metaspace中存放从方法区中转移过来的类信息、常量池、静态变量等数据。

按照正常的生存周期，大部分的对象都会先在年轻代中分配内存空间。当年轻代的空间无法再继续存放更多对象时，就会触发JVM的垃圾回收机制，这种针对年轻代的垃圾回收叫做Young GC或Minor GC，如图4-3所示。

> 图4-3 Young GC / Minor GC

![图4-3 Young GC / Minor GC](chapter04/04-03.png)

而如果年轻代即使经过Minor GC后也无法容纳更多对象时，它们就会通过下面的这几种方式之一进入老年代：

1. 当某个对象在年轻代中逐渐成长，长到足够大时就会被转移到老年代。JVM对这种“成长”的定义是“躲过”一次垃圾回收或转移就算成长一次；
2. 或者，达到动态年龄判断标准时，也会进入老年代；
3. 或者，通过JVM参数直接指定如果对象大小超过预设阈值时，直接进入老年代；
4. 或者，Minor GC之后发现存活对象太多放不下时，也会将部分存活对象直接放入老年代。

但是即使是老年代的空间也是有限的。所以当老年代的空间渐满而无法容纳更多对象时，也会出发老年代的垃圾回收。这种针对老年代的垃圾回收叫做Old GC或Major GC，如图4-4所示。

> 图4-4 Old GC / Major GC

![图4-4 Old GC / Major GC](chapter04/04-04.png)

注意：有的地方把Major GC也叫做Full GC。因为标准不同，所以怎么叫都可以，这都只是“形”，不重要。为了说明方便，这里将老年代的GC统一称为Major GC，之所以如此，主要是考虑到一是和Minor GC对应，二是为了和Full GC相区分，仅此而已。

#### 4.2.2 JVM GC核心参数

Java程序运行时可以通过JVM的GC相关参数来调整年轻代和老年代的存储空间大小，GC相关参数设置的正确和有效与否，会对那些以年为单位持续运行的“三高”系统性能产生决定性影响。不过，在读者能独立做出正确且有效的GC参数设置之前，先要搞清楚以下“5W1H”式的问题：

1. JVM都有哪些GC核心参数（what）；
2. 怎么设置这些GC参数（how）；
3. 为什么这样设置GC参数（why）；
4. 何时设置GC参数（When）
5. 在哪设置GC参数（Where）；
6. 设置何种GC参数（Who）。

先来看看第一个与“What”相关的问题。JVM GC的核心参数如图4-5所示。

> 图4-5 JVM核心参数

![图4-5 JVM核心参数](chapter04/04-05.png)

这些参数表示的意义是：

1. -Xms和-Xmx：用于设置JVM堆内存大小和其最大值，这对参数通常会设置成一样大小，这样性能较好，其值通常从几百MB到几个GB不等；
2. -Xmn：用于设置年轻代大小，一般是JVM堆大小的50%～60%。老年代的大小就是JVM堆大小扣除年轻代后的值，也就是老年代 = Xms - Xmn。-Xms、-Xmx和-Xmn这三者的关系如图4-6所示；

> 图4-6 JVM核心参数

![图4-6 JVM核心参数](chapter04/04-06.png)

3. -XX:MetaspaceSize和-XX:MaxMetaspaceSize：用于设置元空间大小，大小通常为几百MB左右。在JDK1.8之后用它们取代了-XX:PermSize和-XX:MaxPermSize这两个参数。它们的关系类似于-Xms和-Xmx之间的关系；
4. -Xss：用于设置每个线程所能使用的栈内存大小，值通常不大，1MB就算很大了。

具体到Java程序，可以通过命令行、IDE当前环境设置和IDE全局设置三种方式实现运行时指定GC参数。

#### 4.2.3 支付系统案例

在正确且有效地设置GC参数前，有经验的工程师一般会先对系统做一个大致的估算，然后在此基础上根据压测结果做微调，才能最终得到适合业务系统的JVM参数设置。那么问题是，该怎么估算呢？这里以某个电商交易系统为例来说明这种初步估算的步骤和方法。电商支付的极简业务流程如图4-7所示。

> 图4-7 电商支付极简业务流程

![图4-7 电商支付极简业务流程](chapter04/04-07.png)

如果公司的技术BOSS咨询下面的问题，那么架构师该如何回答呢。

1. 我们需要部署多少台机器才能满足需求？
2. 每台机器需要多大的内存空间？
3. 每台机器需要多大的JVM堆内存空间？
4. JVM需要分配多大内存空间才能保证不会崩溃？

要回答上面这些问题，就需要有一个明确的业务衡量标准。例如，每日订单量就是一个不错且当对准确的业务指标。这里笔者假设每天会产生100万笔有效的支付订单。有了业务目标，那么整个初步估算的过程如下。

一般来说，每种业务都会有高峰期和低谷期。这里假设每天的100万笔订单都集中在中午午休和晚餐之后的两个高峰期，每个高峰期各持续两1时，也就是说每天的这100万笔订单，其实是集中在2小时内完成的。那么：

1. 2小时 = 2 × 3600秒 = 7200秒；
2. 100万 ÷ 7200秒 = 138.9单/秒，将系统性能弄紧凑一些，按150单/秒算。

又假设支付系统部署了3台机器，且采取流量均分策略，那么：

1. 每台机器至少每秒需要处理50个订单；
2. 假设整个业务的流程为：支付订单请求 -> JVM创建支付订单对象 -> 写入数据库 -> 处理其他事务 -> 返回数据（不含网络请求时间损耗），理想状态下需要花费20毫秒时间；
3. 接收到50笔支付订单请求则相当于是在JVM年轻代中创建50个订单支付对象 -> 50 × 20毫秒 = 1秒处理完毕；
4. JVM将引用收回，这些订单支付对象就成了年轻代中的待回收垃圾对象，下一秒继续重复上述过程。

整个过程如图4-8所示。

> 图4-8 电商支付极简业务流程

![图4-8 每天100万笔支付订单3台计算机在1秒内可处理完](chapter04/04-08.png)

接下来，生成每笔支付订单所需的内存空间，依据实例对象及变量类型粗略计算为：

1. 每个实例对象的Java基本类型所占据的空间 + 引用对象所占据的空间 ≈ 1KB；
2. 50笔支付订单 = 50K内存空间。

所以，可以预想，如果没有JVM 垃圾回收，当JVM中的对象不停创建且没有被消除时，那么：8 × 1024 × 1024KB = 8388608 / 50笔订单 = 167772 秒 / 3600 ≈ 46小时。也就是说如果每秒消耗50KB，一台存储空间为8G的机器，大概在46个小时之后会将空间耗尽。

但实际上，服务器肯定不会将全部内存给单一应用，最多20%至40%左右。而且整个电商系统也不止订单支付对象。再者业务高峰也许会有好几波，真实的订单数量可能比这多好几倍。所以，资源的实际耗时应该更短，至少要缩水10～20倍左右，即只能支撑2至4个小时左右，取个均值，也就是顶多3小时，系统就会因为内存耗尽而宕机。

以上过程，就是初步估算业务系统配置的方法和步骤。

所以，一般情况下，如果有条件的话只考虑4核8G及以上的计算机配置，针对单台计算机的JVM配置为：-Xms3072M -Xmx3072M -Xmn2048M。如果业务量更大，可以部署5台或10台计算机，甚至更多。

如果JVM GC参数设置不合理，那么当电商遇到促销，例如双十一、除夕夜等情况，访问量可能会提升好几个量级，部分请求出现超时、卡死，甚至应用直接闪退崩溃。而这部分特别慢且未被释放的请求，也极有可能会被GC误移入老年代，导致老年代里也出现越来越多的垃圾对象，由此产生恶性循环。

### 4.3 GC的算法与器

GC是JVM的核心，而垃圾回收算法又是GC的核心。这一节就来看看Java都有哪些垃圾回收算法以及它们是如何工作的。搞清楚这些垃圾回收算法的工作原理，就能更有针对性地选择合适的JDK版本和设置合理的JVM垃圾回收参数，让JVM调优适合业务系统的发展演化。

#### 4.3.1 GC Roots

垃圾回收，首先得区分出哪些东西是垃圾。就像很多人家里都有一个套着塑料袋的小桶那样，会把不要的东西往里扔。这等于是给“垃圾”下了一个定义，或者说“标记”了垃圾的“身份”：所有在垃圾桶里面的都是垃圾，装满了就可以扔。而那些不在垃圾桶里的，就是暂时要保留的了。

对于JVM GC来说也是一样，需要有一种能够“标记”哪些资源可以被“扔掉”（也就是被释放）的方法。所以，Java采用了一种叫做“可达性分析法”的垃圾识别方法。所谓可达性分析，就是判断哪些对象可以被回收释放，而哪些暂时还不能扔。可达性分析的原理如图4-9所示。

> 图4-9 可达性分析

![图4-9 可达性分析](chapter04/04-09.png)

这种存在于方法区、JVM栈、本地方法栈及其他类别的变量引用，统称为GC Roots，把它们作为起始点以链表的方式开始搜索，所搜索的路径称为引用链。当某些对象没有任何GC Roots与之相连时，就证明该对象不可达，也就是可以被回收释放了。所以，从上图可以知道：

1. 引用1、引用2和引用4都是GC Roots；
2. 引用1 引用了 对象实例1；
3. 引用2 引用了 对象实例2 又引用了 对象实例3；
4. 引用4 引用了 对象实例4；
5. 对象实例5虽然引用了对象实例6，但由于对象实例5本身没有任何GC Roots指向它，所以对象实例5和对象实例6都是可以被垃圾回收的对象。

但即使是GC Roots引用也有强弱之分，从强到弱分为四类。如图4-10所示。

> 图4-10 四种不同的引用

![图4-10 四种不同的引用](chapter04/04-10.png)

另外，在JDK 1.9之前，当一个对象没有引用的时候，其垃圾回收器会自动调用它的finalize()方法。但在JDK 1.9之后，该方法已被废弃。所以，随着JDK版本的不断升级，有些方法、类、策略机制等，就没有必要再花多余的时间去了解了。正如之前多线程中stop()、suspend()和resume()这几个被废弃的方法一样。

#### 4.3.2 年轻代GC算法

JVM堆被划分成年轻代和老年代后，新创建的对象会先保存在年轻代。但随着时间的推移，新创建的对象、已使用完的对象和待回收的对象越来越多，当空间不足时，就会引发Young GC或Minor GC。

不过问题在于，在发生Minor GC时，大量有用的和无用的对象全都混在一起，尤其是当回收掉垃圾对象后，会造成很多不连续的内存空白区域，这些空白区域大小不一，碎片化严重，不适合再分配给新对象使用。故而不仅成了极大的空间浪费，还给空间整理和分配工作带来了一定的困难。所以，这种在同一个地方既清除垃圾对象又保留存活对象的做法，实在是一种非常糟糕的方案。

有鉴于此，Java的创造者们在此基础上提出了一种改良的解决方案：

1. 将年轻代再分为大小相等的两块区域A和B；
2. 创建对象实例时先使用区域A，如图4-11所示；

> 图4-11 四种不同的引用

![图4-11 四种不同的引用](chapter04/04-11.png)

3. Minor GC前先在区域A中标记出要保留的存活对象，如图4-12所示；

> 图4-12 在区域A中保留存活对象

![图4-12 在区域A中保留存活对象](chapter04/04-12.png)

4. 再将存活对象转移（复制）到另一块空白区域B中，如图4-13所示；

> 图4-13 将存活对象转移（复制）到另一块空白区域B

![图4-13 将存活对象转移（复制）到另一块空白区域B](chapter04/04-13.png)

5. Minor GC完成后将原区域A整体回收，一并释放，然后由区域B接替区域A的位置存放新创建的对象，如图4-14所示；

> 图4-14 将原区域A整体回收

![图4-14 将原区域A整体回收](chapter04/04-14.png)

6. A、B两块区域再按上述步骤循环往复使用。

上述的“标记”过程，其实也就是探查GC Roots的过程。这种方法的问题是整个年轻代的空间使用效率只有50%。所以Java的创造者们针对此又做了优化改进，如图4-15所示。

> 图4-15 将原区域A整体回收

![图4-15 将原区域A整体回收](chapter04/04-15.png)

从上图可以知道：

1. S0 + S1 = Sruvivor，占据年轻代总空间的20%，S0和S1各占10%。因为每次需要保留的存活对象和需要回收的对象相比，所需空间其实是很有限的；
2. 余下的80%由Eden区使用，因此S0、S1和Eden三部分默认的比例为1:1:8，可以通过JVM参数-XX:SurvivorRatio设置；
3. 一般情况下可以使用Eden区和Survivor其中的一块（比如S0或S1）。

-XX:SurvivorRatio和-XX:NewRatio这两个JVM参数的使用需要特别说明一下，比较容易犯迷糊，如图4-16所示。

> 图4-16 -XX:SurvivorRatio和-XX:NewRatio

![图4-16 -XX:SurvivorRatio和-XX:NewRatio](chapter04/04-16.png)

1. -XX:SurvivorRatio=X的意思是将年轻代分成了X + 2份，其中Eden占X份，S0和S1各占1份；
2. -XX:NewRatio=X的意思是将-Xms分成了X+1份，其中老年代占X份，年轻代占1份。年轻代与老年代空间大小的比例默认为1:2，即默认情况下-XX:NewRatio=2。

经过这样改进后，空间利用率大大提高，做到了资源和效率的平衡。那么，之前在A、B区域的循环复用过程就变成了S0、S1和Eden这三个区之间的循环复用过程：

1. 首先新创建的对象实例优先被分配给Eden和Survivor其中之一（如S0）；
2. 当Eden区的空间快被用尽时，触发Minor GC。其中标记出来的存活对象会一次性转移到另一块空闲的Survivor中（比如S1）；
3. Eden和S0被清空，等待再次分配新对象，如图4-17所示；

> 图4-17 Minor GC后年轻代的状况

![图4-17 Minor GC后年轻代的状况](chapter04/04-17.png)

4. 如果Eden再满，再次触发Minor GC。

此过程在S0、S1和Eden中循环往复。

#### 4.3.3 如何成为JVM的“老人”

在前面提到过对象实例有几种从年轻代进入老年代的方式，在这里就把它们都明确讲述一遍。

1. 首先，第一条规则当对象每在年轻代“躲过”一次GC而被转移到Survivor其中之一时，对象的“年龄”就会增加“一岁”，也就是被标记一次。默认是被标记15次之后，会被转移到老年代。这个默认的标记次数可以通过JVM参数-XX:MaxTenuringThreshold设置；
2. 第二条规则是动态年龄判定规则：如果当前Survivor区中，年龄相同的一批对象总大小 ≥ Survivor × 50%，那么这批对象及比它们年龄更大的对象，就都直接进入老年代。例如将对象的年龄从小打到排序后，如果：“1岁的对象 + 2岁的对象 + ...... + n岁的对象 ≥ Survivor × 50%”，那么所有大于等于n岁的对象就都会进入老年代。这个50%的百分比可以通过JVM参数-XX:TargetSurvivorRatio指定。如图4-18所示。

> 图4-18 动态年龄判定规则

![图4-18 动态年龄判定规则](chapter04/04-18.png)

3. 按年龄排序：对象B + 对象A + 对象C + 对象D = 55MB ≥ 100MB× 50%。因此对象C和对象D进入了老年代。
4. 第三条规则是如果某个对象的大小超过设定的阈值，那么它根本不会进入到年轻代，而是直接进入老年代。这个阈值可以通过JVM参数-XX:PretenureSizeThreshold指定。如图4-19所示。

> 图4-19 大对象阈值规则

![图4-19 大对象阈值规则](chapter04/04-19.png)

5. 最后一条规是如果经过Minor GC后发现剩余的存活对象太多，导致其大小总和超过某个Survivor区（S0或S1），那么就把这些对象转移到老年代。如图4-20所示。

> 图4-20 剩余对象阈值规则

![图4-20 剩余对象阈值规则](chapter04/04-20.png)

上述这四种将年轻代对象转移到老年代的方式，通过表4-1可以很直观地看清楚。

> 表4-1 “年轻人”成长为“老年人”的四种方法

| 类型 | 阈值判断 | 参数 | 说明 |
|:---:|:---:|:---:|:---:|
| 对象年龄标记 | 默认15次 | -XX:MaxTenuringThreshold | 经过多次GC之后的存活对象 |
| 动态年龄标记 | 默认50% | -XX:TargetSurvivorRatio | 对象年龄从小到大排序，最终转移年龄最大及超过最大年龄的对象 |
| 外来对象大小 | 0 | -XX:PretenureSizeThreshold | GC之前要存储到年轻代的对象 |
| 存活对象大小 | 超过Survivor大小 |  | 单次GC之后存活的对象 |

#### 4.3.4 老年代空间分配担保

上面讲的是年轻代对象转移到老年代去的四种方法，但是在老年代的空间足够的前提下进行的。这当然是理想的情况。然而，现实并不总是如此。因为不出意外的话，总会有意外发生——如果这时候老年代的空间也不够了，该怎么办？

这时候JVM的“老年代空间分配担保机制”就会发挥作用。这个机制如果用文字叙述起来比较繁琐，直接看图则会清晰得多。如图4-21所示。

> 图4-21 老年代空间分配担保机制

![图4-21 老年代空间分配担保机制](chapter04/04-21.png)

之所以会有这个“老年代空间分配担保机制”，是因为JVM要想方设法地防止Full GC及其之后的OOM发生。因为这是系统即将或已经崩溃的征兆。

所谓Full GC，就是在整个JVM堆空间中执行垃圾回收，它会清理所有年轻代和老年代中的对象。而执行Full GC时，JVM会直接停止所有系统线程，不接受也不处理任何请求，直到执行完毕。这种现象就是通常所说的“Stop the World”（STW）。如果应用系统频繁出现STW，有些大厂会将之评判为重大事故，它说明JVM GC的性能调优工作存在严重失误。

#### 4.3.5 老年代GC算法

和年轻代一样，老年代如果空间不足时，也会触发垃圾回收机制。老年代垃圾回收的时机可能是在年轻代的Minor GC之前，因为要腾出空间留给年轻代；也可能是在年轻代的Minor GC之后，因为剩余的存活对象太多导致现有空间不足。

由于老年代中没有类似S0、S1和Eden这样的分区，所以它只能在一个单一的场所内既清除垃圾对象，又保留存活对象。这就导致其效率十分低下——它的GC速度只有年轻代的10%。

在G1 GC成为JDK 1.9及其后续版本的默认GC之前，老年代的Old GC或Major GC使用的是一种被称为“标记-清理”的GC算法。这种GC算法的设计思想极其简单，简单到只有两种操作：标记和清理。

1. 标记：先标记出老年代当前的存活对象；
2. 清理：再清理垃圾对象，避免出现碎片化。

但要实现它却不简单。因为清理时可能会造成过多的内存碎片，导致严重浪费空间，所以老年代的Major GC采取GC和正常的系统程序同时执行的方式，算法实现分为四个步骤。

1. 第一步：初始标记阶段。系统进入“Stop the World”状态，GC仅仅标记出所有被GC Roots直接引用的对象，并不会执行清理工作。如图4-22所示。

> 图4-22 初始标记阶段

![图4-22 初始标记阶段](chapter04/04-22.png)

2. 第二步：并发标记阶段。系统程序恢复运行，GC尽可能对全部老年代里已有对象进行GC Roots追踪，即弄清全部老年代里的对象是否被引用了。如图4-23所示。

> 图4-23 并发标记阶段

![图4-23 并发标记阶段](chapter04/04-23.png)

3. 第三步：重新标记阶段。系统程序再次被禁止运行，GC对在上一阶段程序运行时状态发生变更的对象进行标记。这一步相当于是GC和系统程序做同步微调工作。如图4-24所示。

> 图4-24 重新标记阶段

![图4-24 重新标记阶段](chapter04/04-24.png)

4. 第四步：并发清理阶段。系统程序再次恢复运行，GC线程清理掉之前标记为垃圾的对象。如图4-25所示。

> 图4-25 并发清理阶段

![图4-25 并发清理阶段](chapter04/04-25.png)

在老年代Major GC的第四个阶段，即并发清理阶段，会产生一些浮动垃圾，也就是系统程序在GC并发工作时产生的新垃圾。如图4-26所示。

> 图4-26 浮动垃圾

![图4-26 浮动垃圾](chapter04/04-26.png)

这些浮动垃圾要等到下一次GC时才会被清理掉。但如果浮动垃圾过多，可能会导致系统频繁发生“Stop the World”或Full GC。由浮动垃圾引起的GC问题称之为Concurrent Mode Failure（并发模式失败）。如果Major GC之后产生Concurrent Mode Failure问题，也就意味着当次GC执行不彻底，此时JVM会强行再次“Stop the World”，直到垃圾回收完成后再恢复系统线程。为了解决这个问题，JVM预设了一个阈值，当老年代可用空间大于这个阈值时就开始执行Major GC。参数-XX:CMSInitiatingOccupancyFraction可以调节这个阈值，它的默认值是92%，不过在JDK 1.8中该参数已不建议使用。

显然，如果这个阈值设置太小，会增加老年代Major GC频率，但如果设置过大，又会增加Concurrent Mode Failure发生的概率。与浮动垃圾同时产生的，还有无法完全避免的内存碎片问题。JVM也有两个参数来调节：-XX:UseCMSCompactAtFullCollection和-XX:CMSFullGCsBeforeCompaction。但它们在JDK 1.8中都已不建议使用。其中，-XX:UseCMSCompactAtFullCollection会默认打开，作用是Full GC之后再次进行“STW”清理碎片，而-XX:CMSFullGCsBeforeCompaction则表示执行多少次Full GC之后再进行碎片清理，默认值是0，意思是每次都清理。

这就是为什么JVM GC调优工作一定要结合实际业务系统的压测情况来完成的主要原因之一。因为类似这种需要具体情况具体分析解决的地方还有很多，如果不分青红皂白地胡乱用一套所谓通用的JVM参数模板，可能刚开始很正常，但随着系统运行时长和压力的不断增加，迟早会爆发出一堆“莫名其妙”的古怪问题。

#### 4.3.6 垃圾回收器

前面把两种垃圾回收算法都简要讲述了一遍，分别是年轻代Minor GC的“标记-复制”算法和老年代Major GC的“并发-清理”算法。但算法只是一种设计思想，真正完成JVM中垃圾回收工作的，还是要靠具体的垃圾回收器。这就好比发动机的原理并不能代替发动机来开车一样。

自从有了垃圾回收算法以来，先后出现过十几种垃圾回收器。有些是专用于年轻代的，例如Serial、ParNew和Paralle Scavenge等。有些是专用于老年代的，例如Serial Old、CMS和Paralle Old等。而有些则无视这种分代，年轻代和老年代都可以通用，例如G1和ZGC等，“标记-清理”算法就是专门针对老年代的CMS垃圾回收器。所有针对不同分代的垃圾回收器及其背后的垃圾回收算法，都可以统称为“分代回收器”和“分代回收算法”。

年轻代之所以以“复制”方式为主，是因为年轻代的每次垃圾回收都会有近99%的内存空间被释放，而“复制”方式只需要付出少量对象的复制成本就可以完成大量的垃圾回收。而老年代之所以选择“清理”方式，是因为老年代中对象的存活几率相对较高，而且没有额外的空间可以对它进行分配担保，所以只有通过“标记-清理”的方式进行垃圾回收。

图4-27所示是到目前为止Java较为主流的垃圾回收器。对它们的总结如表4-2所示。

> 图4-27 主流的垃圾回收器

![图4-27 主流的垃圾回收器](chapter04/04-27.png)

> 表4-2 主流垃圾回收器比较

| 垃圾回收器 | 适用于 | GC算法 | 线程 | JVM控制参数 |
|:---:|:---:|:---:|:---:|:---:|
| Serial | 年轻代 | 标记-复制算法 | 单线程 | -XX:+UseSerialGC |
| ParNew | 年轻代 | 标记-复制算法 | 多线程 | -XX:+UseParNewGC |
| Paralle Scavenge | 年轻代 | 标记-复制算法 | 多线程 | -XX:+UseParallelGC |
| Serial Old | 老年代 | 标记-清理算法 | 单线程 | -XX:+UseSerialOldGC |
| CMS | 老年代 | 标记-清理算法 | 多线程 | -XX:+UseConcMarkSweepGC |
| Paralle Old | 老年代 | 标记-清理算法 | 多线程 | -XX:+UseParallelOldGC |
| G1 | 不分代 | 标记-清理算法 | 多线程 | -XX:+UseG1GC |
| ZGC | 不分代 | 改进的标记-复制算法 | 多线程 | -XX:+UseZGC |

#### 4.3.7 JVM调优案例

搞清楚了垃圾回收算法、垃圾回收器之后，就可以看看在实际的生产环境中该如何调整JVM参数了。

仍然以之前讲过的支付系统为例，假设年轻代指定的垃圾回收器为ParNew，老年代指定的垃圾回收器为CMS。目前的业务简化后的状况是：

1. 支付系统遇到节假日大促，DAU达到了500万，峰值订单量达到了1000笔/秒；
2. 现有3台计算机，平均每台至少需承接330笔/秒的订单量。以保守情况预估，按每台计算机每秒承接500笔订单的请求量来计算；
3. 计算机的配置为4核8GB内存，按JVM × 2 = 物理内存来计算，那么JVM应分配到4GB的内存空间；
4. JVM堆分配3GB内存空间，其余留给JVM中的方法区、栈、程序计数器、本地方法栈和其他部分；
5. 默认情况下，JVM年轻代和老年代的内存大小比例是1:2。但为了避免年轻代被很快填满，所以这里将年轻代和老年代的比例调整为1:1，也就是都设置为1.5GB；
6. 经预估，每笔订单信息输入的数据量大概在1KB左右，而连带的订单详情、优惠券、SKU、物流等信息，需要将订单对象的开销放大10～20倍，这里按20倍计算；
7. 除此之外，订单系统还会有很多相关的其他操作，比如查询、发消息，所以这些算起来，还要在上一步的基础上再扩大10倍的开销。

综合以上信息，整个订单系统的案例背景如图4-28所示。

> 图4-28 订单系统的案例背景

![图4-28 订单系统的案例背景](chapter04/04-28.png)

因此，初始的JVM GC参数就可以配置为：

1. -Xms3072M -Xmx3072M
2. -Xmn1536M -Xss1M
3. -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M

因为在JDK 1.6之后不再需要-XX:HandlePromotionFailure这个参数，所以就不加了。按图4-28所示的估算，订单系统每秒会生成100MB的数据填充年轻代。可以预见，照此速度，15秒之后，年轻代就会被填满。

如果JVM参数-XX:SurvivorRatio=8，那么Eden将只有1.2G，会不等到15秒而提前触发Minor GC。

增加-XX:SurvivorRatio后，JVM GC参数调整为：

1. -Xms3072M -Xmx3072M -Xmn1536M -Xss1M
2. -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=8

增加这个参数的目标就是避免年轻代被填得连Minor GC的空间都没有了。但调整Survivor空间时，也要注意几个问题：

1. 有可能会出现Survivor空间不足而直接进入老年代的情况；
2. 动态年龄判定规则：全部对象大小之和超过Survivor空间50%会直接进入老年代；
3. 单次GC之后存活对象大小超过Survivor，则直接进入老年代。

因此，基于如上考虑，一方面可以适当调整年轻代的大小，因为普通业务系统的大部分对象生存周期都很短，根本不应该进入老年代，而是要尽量让它们留在年轻代里。另一方面，也可以增加Survivor空间，根据动态年龄判定规则，增加-XX:TargetSurvivorRatio参数，让可以长久存活的尽量早点进入老年代，给Survivor腾出空间处理新对象。如图4-29所示。

> 图4-29 调整年轻代大小

![图4-29 调整年轻代大小](chapter04/04-29.png)

按照上图，JVM GC参数也需要相应调整为：

1. -Xms3072M -Xmx3072M -Xmn2048M -Xss1M
2. -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M
3. -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=30

同时，可以降低进入老年代的年龄门槛限制，给Survivor腾出更多空间。那么需要给JVM增加-XX:MaxTenuringThreshold参数了。

1. -Xms3072M -Xmx3072M -Xmn2048M -Xss1M
2. -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M
3. -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=30 -XX:MaxTenuringThreshold=5

而且可以指定某些超过指定大小的内存对象直接进入老年代，减轻Survivor存储压力，所以可以给JVM增加-XX:PretenureSizeThreshold参数。

1. -Xms3072M -Xmx3072M -Xmn2048M -Xss1M
2. -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M
3. -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=30
4. -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=10MB

之前提过Concurrent Mode Failure的问题，但这种概率极小，不需要为极小概率事件调整JVM参数设置。也没有必要修改执行多少次Full GC之后进行碎片清理，因为经过优化后， Full GC执行次数大大降低了。而且即使是在大促期间，真正的系统压力峰值时间也是有限的，比如持续2小时可能就结束了。如果JVM能做到500单/秒，大约1小时才触发一次Full GC，那么峰值过后，JVM的压力就会小很多，就不会再触发Full GC了。

最后，要记得给年轻代和老年代指定所要使用的垃圾回收器：

1. -Xms3072M -Xmx3072M -Xmn2048M -Xss1M
2. -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M
3. -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5
4. -XX:TargetSurvivorRatio=30 -XX:PretenureSizeThreshold=10MB
5. -XX:+UseParNewGC -XX:+UseConcMarkSweepGC

以上的JVM GC参数设置，就是根据压测或大促期间的订单系统表现而逐步调整出来的。当然，它还需要经过实践的检验，还需要在业务运行期间不断根据实际需要而进行调整。

### 4.4 G1 GC

自从出现了专门用于年轻代GC的ParNew和只针对老年代GC的CMS垃圾回收器后，一方面，它们始终无法彻底解决“STW”的问题。另一方面，多核处理器和超大容量内存的出现，也对JVM提出了更苛刻的要求：在尽量降低GC停顿时间的同时也要有更高的吞吐量。在以上种种背景条件之下，G1垃圾回收器诞生了。

#### 4.4.1 “垃圾优先”

从JDK 1.9开始，G1就代替了传统的垃圾回收器，成了JVM的默认GC算法（JEP 248: Make G1 the Default Garbage Collector）。G1全称Garbage-First Garbage Collector，即“垃圾优先垃圾回收器”，意思就是如果有垃圾就优先清理垃圾。它和之前的Serial、ParNew、CMS等基于分代回收理论的垃圾回收器不同，G1 GC淡化了分代的概念，将整个JVM堆看作一个整体并将它们从逻辑上拆分为多个大小固定的内存块，也称为Region。如图4-30所示。

> 图4-30 G1的5种Region

![图4-30 G1的5种Region](chapter04/04-30.png)

G1五种不同的Region分别是：

1. Survivor Region：年轻代Survivor区的Region；
2. Eden Region：年轻代Eden区的Region；
3. Old Region：老年代的Region；
4. Humongous Region：巨型Region，如果待存储的对象大小 ≥ 单个Region × 50%，那么就会被判断为大对象。如果单个Region存不下，将使用连续的多个Region存放，并将这些Region都标记为巨型Region；
5. Free Region：暂时未使用的空闲Region。

G1最多可以有2048个Region，而Region的大小又可以是1MB、2MB、4MB、8MB、16MB和32MB这六种中的一种。因此G1最多可以管理32MB × 2048 = 64GB的JVM堆空间。或者反过来说，如果不知道该给Region设置多大合适，那么Region大小 = 堆内存 / 2048。例如，当堆内存为8192GB时，那么Region大小就应该设置为8192GB / 2048 = 4MB。

由于G1的Region都是大小固定的内存块，而且最多2048个，所以借助于多核CPU和多线程技术，它完全可以同时控制多个Region的垃圾回收动作，以达到精准控制GC的停顿时间和区位分布的目的，而这也是G1最主要的设计目标：将无法避免的“Stop the World”问题变为可预期且可配置的。G1默认的期望最大停顿时间为200毫秒，只不过它不是硬性条件，而是期望值。

G1之所以可以控制预期的GC时间，是由于其设计思路的缘故。简单来说就是：垃圾是永远也清不完的，与其花费太多时间把一段时间内的垃圾全都清完，倒不如多清理几次，每次清理一点。这样既不降低业务系统的执行速度，也能整体提升垃圾回收效率。G1就是这种在“全部清理完”Vs.“每次清一点”之间取得了良好平衡的GC算法。而且G1会追踪堆中的每个Region，如果之前的GC已经造成了系统卡顿，当又要进行GC的时候，就会评估回收哪个Region中的垃圾更合理，做到在尽可能短的时间内回收尽可能多的垃圾。例如，每个Region都有多少垃圾？需要花费多少时间回收？很明显，花费1秒回收10MB垃圾和花费200毫秒回收20MB垃圾，当然是后者的性价比更高——这就是所谓的“回收价值”——它是G1通过估算预期卡顿时间与已卡顿时间之间的差值得来的。

而且，G1中年轻代，也就是Survivor Region和Eden Region占全部JVM内存的比例默认为5%，最多不高于60%。它们由-XX:G1NewSizePercent=5和-XX:G1MaxNewSizePercent=60这两个参数决定。且Survivor Region和Eden Region的默认比例也仍然是1:1:8，它由参数-XX:SurvivorRatio=8决定。也就是说，如果年轻代有100个Region，那么S0 Region和S1 Region各占10个，Eden Region占80个。如图4-31所示。

> 图4-31 Servivor Region和Eden Region的默认比例

![图4-31 Servivor Region和Eden Region的默认比例](chapter04/04-31.png)

当某个Survivor Region被回收之后，它后续可能会变成Eden Region或者Old Region，所以每个Region的“身份”都不是一成不变的。这样的话，内存管理就会很灵活，既能动态满足年轻代和老年代的空间需求，又最大限度地提升了空间利用率。

#### 4.4.2 G1那些事儿

G1将JVM重新划分为若干个Region之后，还同时准备了若干辅助“道具”以便它们能更好地发挥自身特长。下面就来一一介绍。

在JVM运行过程中，内存分配是一个极其频繁的动作，尤其是还有大量线程同时申请，如果不加以控制，势必会拉低系统整体性能。所以G1 GC中引入了一个叫TLAB的组件，它的全称是Thread Local Allocation Buffer，即“线程本地分配缓冲”。它让每个线程都单独拥有一个Buffer，如果需要分配内存，就在先自己的Buffer上分配而不用向JVM申请，当Buffer不够用的时候，再重新向Eden区申请一个，这样就可以大大提升系统效率。如图4-32所示。

> 图4-32 TLAB

![图4-32 TLAB](chapter04/04-32.png)

需要注意的是，TLAB的内存分配指针是线程私有的，但其中的数据是可以给所有线程访问的，而非只能自己使用。

由于G1 GC并未完全抛弃分代回收模型，所以它一般是先回收年轻代，不行的话就开始混合回收，最后实在不行再执行Full GC。由于年轻代和老年代是不同的，如果用GC Roots可达性分析，就会把老年代也一并收集一遍，这就比较浪费时间。而且年轻代也可能会有老年代引用，反过来也一样。所以，为了解决这种跨代分析和引用问题，G1使用了一种叫做Remember Set的东西，也叫记忆集。它用一组KV键值对，记录了跨代引用关系，在垃圾回收的时候，就可以快速搞定跨代引用的可达对象分析问题，如图4-33所示。

> 图4-33 RSet

![图4-33 RSet](chapter04/04-33.png)

RSet专门用来存储所有跨代引用的对象，因为同代引用已经有GC Roots了。而且RSet是存在于Region维度的，也就是每个Region都有一个自己的RSet。之所以如此，是因为每次GC之后Region都会不断地变化，如果粒度太粗，就完全起不到它应有的作用。

G1为了在并发阶段描述内存的使用状态，创造了一个叫做BitMap位图的组件。所谓位图，其实就是一组由0和1组成的字符串，0代表某块内存未使用，而1代表已使用，如图4-34所示。

> 图4-34 BitMap

![图4-34 BitMap](chapter04/04-34.png)

除了位图，还有一个和它比较类似的东西，叫做CardTable卡表，也是用一段数据去记录内存的使用情况。但卡表和位图的不同在于：位图要么是0，要么是1。也就是它只能记录使用或未使用这两种状态，而卡表有8位，用一个字节byte来描述内存的使用状况，所以它就能够承载多达2的8次方，即256种不同的状态信息，例如是否使用、内存的引用关系等，如图4-35所示。

> 图4-35 CardTable

![图4-35 CardTable](chapter04/04-35.png)

上图中第1位表示是否使用，而后7位可以表示其他相关信息。位图和卡表一样，在G1中都是全局性的，也就是整个G1就这么独一份。

在G1的每次垃圾回收时，都会释放一部分Region。如果这些Region一个一个地处理，显然比较浪费时间。因此G1用了一个叫做CSet的组件，它将每次垃圾回收期间需要释放的Region都集中在一起处理。CSet中的Region既可以是年轻代的Survivor Region和Eden Region，也可以是老年代的Old Region，或者Humongous Region。而G1会将CSet中存活的对象拷贝到新的Region，然后释放CSet中的这些Region，如图4-36所示。

> 图4-36 CSet

![图4-36 CSet](chapter04/04-36.png)

最后，由于GC和应用程序是并发执行的，可能某个对象刚被GC标记之后，应用程序就立即对它进行改动，从而造成对象的漏标或误标问题。误标影响不大，但漏标就有点严重了：如果某个本应存活的对象未被标记存活，反而被垃圾回收给销毁了，其影响可能会非常严重，甚至会造成应用程序的闪退或崩溃。为了解决这个问题，G1采用了一种称为SATB（Snapshot-At-The-Beginning）的技术，也就是“初始快照”。它在GC开始时的并发标记阶段，给所有通过GC Roots得到的存活对象一个“快照”。同时将对象按标记状态分成三种“颜色”，如图4-37所示：

> 图4-37 对象的三色标记

![图4-37 对象的三色标记](chapter04/04-37.png)

上图中的“黑”、“白”、“灰”三种颜色分别表示：

1. 黑色：自身及可达对象都被标记，所以不会再对它进行扫描；
2. 灰色：自身被标记，但可达对象未标记；
3. 白色：完全未被标记。

显然，白色就是漏标的对象。造成这种情况的可能原因是在并发标记阶段，GC标记之后，要么业务线程紧接着给某个黑色对象的成员变量赋值了白色对象；要么业务线程紧接着“不小心”删除了某个灰色对象到白色对象的引用。为了解决这个问题，SATB用到了两个位图，这两个位图都存储在每个Region中，用来记录上一次完成标记的位置preTAMS和当前标记的位置nextTAMS。通过这两个位图、pre-write barrier和post-write barrier技术，SATB可以保证对象不会被漏标，但却无法消除浮动垃圾。

以上两小节就是G1的“通用知识”。所谓“通用知识”指的是这些内容从JDK 8开始直到JDK 21中都是适用的，基本没有什么改变。之所以选择JDK 21，是因为它是第一个发布了Java协程，也叫“虚拟线程”（JEP 444: Virtual Threads）的稳定版本，也是第一个发布了分代ZGC（JEP 439: Generational ZGC）的版本。而这两者刚好都对G1有影响，这可能预示着G1 GC也即将发生一些变化。

另外，JDK 21也是Oracle官方路线图明确标识出的LTS版，即Long Time Support长期支持版。所以JDK 21可能会是一个分水岭。如果有必要的话，可以尝试把项目迁移到JDK 21上，除了需要做一些JVM参数的调整之外，代码层面基本上不会有什么变化。

笔者也建议直接采用ZGC，因为官方文档明确表示它最大支持16TB内存，STW的停顿时间小于10毫秒，GC期间对吞吐量的影响比G1要小15%。所以综合比较下来，它的效率又比G1 GC要高出一截。

#### 4.4.3 同一个Java，不同的G1

对G1有了大致的了解之后，就可以来看看在不同的JDK中它的算法执行过程会有什么不同了。在JDK 8中，G1有三种GC类型，它们分别是：

1. Young GC：年轻代GC，回收所有Survivor Region和Eden Region；
2. Mixed GC：混合GC，回收所有Survivor Region、Eden Region和部分Old Region；
3. Full GC：回收全部JVM堆中的Region。

JDK 8的Young GC和之前讲过的年轻代GC算法比较类似，当所有年轻代Region的空间之和 ≥ -XX:G1MaxNewSizePercent所设置的值时，就会触发G1的Young GC，这个值默认是60%。而且对象从“年轻代”进入“老年代”的第一条年龄规则和第二条动态年龄判断规则对G1也同样适用。Young GC过程可参考之前的内容，这里就不再重复讲述。

Mixed GC也类似于老年代的CMS GC过程，当全部Old Region ≥ JVM堆内存大小 × 45%时，就触发混合回收。这个45%是通过JVM参数-XX:InitiatingHeapOccupancyPercent设置的。也就是说，如果JVM有2048个Region，那么当Old Region = 2048 × 45% ≈ 922 个时，就会触发Mixed GC。Mixed GC分为五步。

1. 第一步是Initial Mark初始标记阶段：这一步会引起“Stop the World”，使用单线程快速标记GC Roots可以直连的对象。该阶段是在Young GC的基础上进行的；
2. 第二步是Root region Scanning GC Roots区域扫描阶段：它扫描前一步剩余的区域，查找部分老年代的引用并标记它，并修改TAMS指针的值。此阶段系统程序恢复运行，它必须在下一个Young GC前完成；
3. 第三步是Concurrent Marking并发标记阶段：此时发生“Stop the World”，系统程序停止运行，GC在整个JVM堆中开始进行可达性分析，标记要回收的对象，扫描完成后重新处理STAB记录下的在并发时有引用变动的对象；
4. 第四步是Remark备注阶段：也叫最终标记。系统会再次“Stop the World”，纠正并发标记阶段因程序操作而导致的错标、误标、漏标对象；
5. 最后一步是Cleanup清理阶段：该阶段会统计和清理RSet，识别完全空闲的区域和Mixed GC的候选对象，从而引发“Stop the World”。在此阶段，GC不仅回收Survivor Region、Eden Region和部分Old Region，也会回收Humongous Region，并将它们放回空闲区域列表。在满足性能的前提下，即在允许GC卡顿的时间内，GC对各个Region区的回收价值和成本进行排序，找出“回收价值最大”的Region优先回收。

至于Full GC，当Mixed GC没有回收掉或来不及回收垃圾对象，也就是回收失败时，它就被触发执行。Full GC会回收整个JVM堆全部的Region。它会执行下面的一系列动作：

1. 停止系统运行；
2. 采用单线程或多CPU并行方式进行整个JVM的标记、清理、压缩和整理；
3. 回收垃圾，空闲出一批Region；
4. 恢复混合回收过程。

其总体流程如图4-38所示。

> 图4-38 JDK 8中G1 Full GC整体流程

![图4-38 JDK 8中G1 Full GC整体流程](chapter04/04-38.png)

在JDK 21中的G1突出了Young GC的重要性。毕竟在JVM堆空间得到极大扩展后，大部分对象都是在年轻代中处理的。JDK 21把G1 GC分成了两个不断循环往复的阶段，它们共同组成了G1 GC的垃圾回收周期，如图4-39所示。

> 图4-39 JDK 21中G1 GC两大阶段

![图4-39 JDK 21中G1 GC两大阶段](chapter04/04-39.png)

从图中可以看到，当老年代的占有率超过参数-XX:InitiatingHeapOccupancyPercent=45设定的值时，就引发Young-Only GC。其中每个圆圈都代表一次GC停顿：

1. 左边的蓝色圆圈表示Young-Only GC引起的停顿；
2. 右边的橙色圆圈表示标记过程中的停顿；
3. 下方的红色圆圈表示Mixed混合回收过程中的停顿。

“Young-Only”阶段又细分为三个小阶段：

1. Concurrent Start（并发开始）阶段：它启动并发标记，确定并保留在老年代中当前所有的可达对象，即存活对象。此阶段结束时会有两个导致“Stop the World”的阶段出现，分别是“备注阶段”和“清理阶段”。但这个阶段也有可能不会标记，也就没有了后续的阶段；
2. Remark（备注）阶段：此时停止标记，处理一些弱引用和无用的对象，回收完全空闲的区域并清理内部数据结构，在下一阶段到来前搜集老年代中的可回收空间；
3. Cleanup（清理）阶段：这个阶段决定是否执行下一个阶段，即“Space Reclamation”。如果是的话，将进入混合回收阶段。

“Space Reclamation”阶段类似于之前的Mixed GC，它包括多次混合回收，整个阶段都是“Stop the World”。而且除了所有年轻代的Region，它也会根据并发标记阶段得出的回收价值数据对老年代进行回收。此阶段之后，整个G1 GC的垃圾回收周期就结束了，然后又开始进入下一个“Young-Only”阶段，如此循环往复。

如果G1 GC如果出现“Evacuation Failure”，那么意味着大概率即将执行Full GC。其过程就不再赘述。总的来说，从JDK 8到JDK 21，G1 GC虽然在技术上没有大的改变，但它在向Young GC倾斜，更紧凑且更聚焦了。表4-3对比了G1 GC在JDK 8和JDK 21官方文档中的一些不同。

> 表4-3 JDK 8 G1和JDK 21 G1的简单比较

| 对比项 | JDK 8 G1 | JDK 21 G1 |
|:---:|:---:|:---:|
| 可用的垃圾回收器 | -XX:+UseSerialGC<br>-XX:+UseParNewGC<br>-XX:+UseParallelGC<br>-XX:+UseSerialOldGC<br>-XX:+UseConcMarkSweepGC<br>-XX:+UseParallelOldGC<br>-XX:+UseG1GC | -XX:+UseSerialGC<br>-XX:+UseParallelGC<br>-XX:+UseG1GC-XX:+UseZGC<br>-XX:+UseZGC<br>-XX:+ZGenerational |
| 垃圾回收类型 | 1. Young GC<br>2. Mixed GC<br>3. Full GC | 1. Young-Only<br>2. Space-Reclamation<br>3. Full GC |
| 具体执行阶段 | 1. Initial marking phase<br>2. Root region scanning phase<br>3. Concurrent marking phase<br>4. Remark phase<br>5. Cleanup phase | 1. Concurrent Start<br>2. Remark<br>3. Cleanup |












#### 4.4.4 实践案例

















### 4.5 GC日志


























### 4.6 可视化工具





























#### 4.7 本章小节





















#### 4.7 本章练习
